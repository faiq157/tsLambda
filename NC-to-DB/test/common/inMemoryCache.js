const _isString = require('lodash/isString');
const _filter = require('lodash/filter');
const _values = require('lodash/values');
const {redisStreamErrorString} = require("../../utils/constants");

let lists = {};
let map = {};
let promises = {};
let subscriptions = {};
let stream = {};
let isMulti = false;
let multiResp = [];
let channelMessageHandler = null;

class AtLeastPolicy {

  constructor(config) {
    this._config = config;
  }

  evaluate(history) {

    const objective = {};
    Object.keys(this._config).forEach((key) => {
      const value = this._config[key];

      const occurrences = _filter(history, item => item === key).length;

      objective[key] = occurrences >= value;
    });

    const objectiveMet = _values(objective).reduce((acc, item) => acc && item);

    // console.log(`object met: ${objectiveMet}. history: ${JSON.stringify(history)}`);
    return objectiveMet;
  }
}

class AnyMatchPolicy {
  constructor(config) {
    this._config = config;
  }

  evaluate(history) {

    const objective = {};
    Object.keys(this._config).forEach((key) => {
      const value = this._config[key];

      const occurrences = _filter(history, item => item === key).length;

      objective[key] = occurrences >= value;
    });

    const objectiveMet = _values(objective).reduce((acc, item) => acc || item);

    //console.log(`object met: ${objectiveMet}. history: ${JSON.stringify(history)}`);
    return objectiveMet;
  }
}

const incrAsync = (key) => {
  const value = map[key] || 0;
  map[key] = value + 1;
  return Promise.resolve(String(map[key]));
};

const setKey = (key, value) => {
  map[key] = value;

  if (promises[key]) {
    const { fns } = promises[key];
    fns.forEach(fn => fn(value));
  }
};

const lpushAsync = (key, value) => {

  if (!_isString(key)) {
    throw new Error("expected string for parameter 'key'");
  }

  if (!_isString(value)) {
    throw new Error("expected string for parameter 'value'");
  }

  lists[key] = lists[key] || [];

  lists[key].unshift(value);

  return Promise.resolve();
};


const brpopAsync = (key) => {

  if (!_isString(key)) {
    throw new Error("expected string for parameter 'key'");
  }

  const list = lists[key];

  return Promise.resolve([
    key,
    list && list.length > 0
      ? list.pop()
      : '--stop-processing--'
  ]);
};

const delAsync = async (key) => {
  const res = await exists(key)
  delete map[key];
  return res? Promise.resolve(1) : Promise.resolve(0)
};

/*
 * This method returns the records by applying start-end time calculations in ASCENDING order
 */
const xRange = (key, startTime, endTime, options) => {
  const tempStream = {...stream};
  let resp = tempStream[key]?.filter(s => {
    if (startTime && endTime == '+') {
      return startTime <= s.id.split('-')[0];
    } else if (startTime == '-' && endTime) {
      return endTime >= s.id.split('-')[0];
    } else if (startTime && endTime && startTime != '+' && endTime != '-') {
      return startTime <= s.id.split('-')[0] && endTime >= s.id.split('-')[0];
    }
  });
  if (options?.COUNT) {
    resp = resp.splice(0, options.COUNT);
  }
  if (isMulti && resp) {
    multiResp.push(resp);
  }
  return resp;
};

/*
 * This is the reverse of XRANGE
 * and this method returns the records by applying start-end time calculations in DESCENDING order
 */
const xRevRange = (key, startTime, endTime, options) => {
  const tempStream = JSON.parse(JSON.stringify(stream));
  tempStream[key].sort((a, b) => parseInt(b.id.split('-')[0]) - parseInt(a.id.split('-')[0]));
  let resp = tempStream[key]?.filter(s => {
    if (startTime && endTime == '-') {
      return startTime >= s.id.split('-')[0];
    } else if (startTime == '+' && endTime) {
      return endTime <= s.id.split('-')[0];
    } else if (startTime && endTime && startTime != '+' && endTime != '-') {
      return startTime <= s.id.split('-')[0] && endTime >= s.id.split('-')[0];
    }
  });
  if (options?.COUNT) {
    resp = resp.splice(0, options.COUNT);
  }
  if (isMulti && resp) {
    multiResp.push(resp);
  }
  return resp;
};

const xAdd = (key, eventId, payload, options) => {
  let isAutoGeneratedEventId = (eventId === '*');
  let isAutoGeneratedIdentifier = eventId.includes('-*');
  let dataObj = null;
  if (eventId === '*') {
    eventId = new Date().getTime();
  }
  const matchingEventIdsCount = stream[key] ? stream[key].filter(s => s.id.includes(eventId.replace('-*', ''))).length : 0;
  const greaterEventIdExist = stream[key] ? stream[key].some(s => parseInt(s.id) > parseInt(eventId.replace('-*', ''))) : false;
  if (greaterEventIdExist) {
    if (isMulti) {
      if (multiResp.length == 0) {
        multiResp = {
          message: '',
          replies: [],
          errorIndexes: []
        };
      }
      multiResp.message = 'MultiErrorReply: X commands failed, see .replies and .errorIndexes for more information'
      const errorIndex = multiResp?.replies?.push({message: redisStreamErrorString.XADD_ID_EQUAL_OR_SMALLER}); // If insertion was made on index 0, it will return 1
      multiResp.errorIndexes.push(errorIndex -1);
      return false;
    }
    return Promise.reject({message: redisStreamErrorString.XADD_ID_EQUAL_OR_SMALLER});
  }
  if (!stream[key] && options.NOMKSTREAM) {
    return false;
  }
  if (isAutoGeneratedIdentifier || isAutoGeneratedEventId) {
    eventId = isAutoGeneratedIdentifier ? eventId.replace('*', matchingEventIdsCount): eventId;
    dataObj = {
      id: `${eventId}`, // event ids format: 1685966597000-0
      message: payload
    };
  } else {
    if (matchingEventIdsCount > 0) {
      return Promise.reject({message: redisStreamErrorString.XADD_ID_EQUAL_OR_SMALLER});
    }
    dataObj = {
      id: `${eventId}`, // event ids format: 1685966597000-0
      message: payload
    };
  }

  stream[key] ? stream[key].push(dataObj) : stream[key] = [dataObj];
  if (!isMulti) {
    return Promise.resolve(eventId);
  }
  if (isMulti) {
    if (multiResp.length == 0) {
      multiResp = {
        replies: [],
        errorIndexes: []
      };
    }
    multiResp?.replies?.push(eventId);
    return;
  }
  return eventId;
};

const exec = () => {
  isMulti = false;
  const resp = multiResp?.errorIndexes ? multiResp : [...multiResp];
  multiResp = [];
  if (resp?.errorIndexes?.length > 0) {
    return Promise.reject(resp);
  }
  return Promise.resolve(resp);
};

const set = (key, value, ...rest) => {

  if (!_isString(key)) {
    throw new Error("expected string for parameter 'key'");
  }

  if (!_isString(value)) {
    throw new Error("expected string for parameter 'value'");
  }

  if (rest.length > 0) {
    if (rest[rest.length - 1] === 'NX') {
      // only set the value if the key doesn't already exist
      if (map[key]) {
        // don't do anything, resolve with null
        return Promise.resolve(null);
      }
    } else if (rest[rest.length - 1] === 'XX') {
      // only set the key if it already exists
      if (!map[key]) {
        // don't do anything, resolve with null
        return Promise.resolve(null);
      }
    }
  }

  setKey(key, value);
  return Promise.resolve('OK');
};

const hmsetAsync = (key, hashMap) => {

  // redis stores all values as strings
  const obj = {};
  for (let prop in hashMap) {
    if (hasOwnProperty.call(hashMap, prop)) {
      const val = hashMap[prop];
      obj[prop] = val !== null && val !== undefined ? val.toString() : 'null'; // redis will store this as 'null'
    }
  }

  setKey(key, obj);
  return Promise.resolve('OK');
};

const hgetallAsync = (key) => {
  return Promise.resolve(map[key]);
}

const resolveOnKeySet = (key, policy) => {

  const callbacks = {
    resolve: null,
    reject: null
  };

  const promise = new Promise((resolve, reject) => {
    callbacks.resolve = resolve;
    callbacks.reject = reject;
  });

  const fn = (value) => {

    const { callHistory } = promises[key];
    callHistory.push(value);

    const payload = {
      value,
      callHistory
    };

    if (policy) {
      const policyMet = policy.evaluate(callHistory);
      if (policyMet) {
        return callbacks.resolve(payload);
      }
    }
  };

  // allow for multiple clients to resolve on the same key
  promises[key] = promises[key] || {
    fns: [],
    callHistory: []
  }
  promises[key].fns.push(fn);

  // if we already have a value, call the fn
  if (map[key]) {
    setKey(key, map[key]);
  }

  return promise;
};

const get = (key) => {
  return Promise.resolve(map[key]);
};

const on = (str, fn) => {
  channelMessageHandler = fn;
};

const exists = (key) => {
  return map[key]? Promise.resolve(1) : Promise.resolve(0)
};

const subscribe = (channel) => {
  subscriptions[channel] = 1;
};

const publishAsync = (channel, message) => {
  const subscription = subscriptions[channel];
  if (subscription && channelMessageHandler) {
    return channelMessageHandler(channel, message);
  }

  return Promise.resolve();
};

const flushallAsync = () => {
  lists = {};
  map = {};
  stream = {};
};

const expire = () => {
  return Promise.resolve();
};

const multi = () => {
  isMulti = true;
  return instance;
};

const instance = {
  brpopAsync,
  flushallAsync,
  get,
  hgetallAsync,
  hmsetAsync,
  incrAsync,
  lpushAsync,
  on,
  publishAsync,
  delAsync,
  set,
  subscribe,
  expire,
  exists,
  xRange,
  xRevRange,
  xAdd,
  multi,
  exec
};

const getCacheClient = () => instance;

module.exports = {
  getCacheClient,
  resolveOnKeySet,
  AtLeastPolicy,
  AnyMatchPolicy
};
